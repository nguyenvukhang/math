#!/usr/bin/env python3

from argparse import ArgumentParser
import os, re, time, datetime
from os import path
from subprocess import Popen, PIPE
from typing import TypeVar, Literal, Callable
import typing

SECTION_TITLES = (
    b"Algorithm",
    b"Corollary",
    b"Definition",
    b"Example",
    b"Exercise",
    b"Lemma",
    b"Problem",
    b"Proposition",
    b"Remark",
    b"Result",
    b"Theorem",
)


T = TypeVar("T")


class Regex:
    LABEL = re.compile(b"\\\\label{([a-z0-9]{7})}")
    LABEL_ENDL = re.compile(b"\\\\label{([a-z0-9]{7})}$")
    HREF = re.compile(b"\\\\href{([a-z0-9]{7})}")
    STAR_NUM = re.compile(b"^\*\[\d+\]$")


class File:
    def __init__(self, filepath):  # type: (str) -> None
        self.filepath = filepath
        self.lines = read_file(filepath).splitlines()

    # collect all labels into a set
    # fails if a duplicate label is found
    def get_labels(self, existing):  # type: (File,  set[bytes]) -> None
        for i in range(len(self.lines)):
            line = self.lines[i]
            if get_section_title(line) is None:
                continue
            if not section_is_one_line(line):
                print(f"[ERROR] Title spans multiple lines in")
                print(f"| {self.filepath} | line {i} |")
                exit()
            hit = Regex.LABEL.search(line)
            if hit is None:
                continue
            label = hit.groups()[0]
            if label in existing:
                raise Exception("Found a duplicate label: %s" % label.decode("utf8"))
            existing.add(label)

    # ensures that all references are pointed to a defined SHA.
    def check_references(self, existing):  # type: (File, set[bytes]) -> None
        for line in self.lines:
            hit = Regex.HREF.search(line)
            if hit is None:
                return
            ref = hit.groups()[0]
            if ref not in existing:
                print("undefined reference:", ref)

    # add labels to unlabelled section titles
    def add_labels(self, existing):  # type: (File, set[bytes]) -> None
        for i in range(len(self.lines)):
            l = self.lines[i]
            if Regex.LABEL_ENDL.search(l) is not None or get_section_title(l) is None:
                continue
            self.lines[i] += b"\\label{" + new_sha(existing) + b"}"

    def write(self):
        write_file(self.filepath, self.lines)


def new_sha(existing):  # type: (set[bytes]) -> bytes
    from random import randint as r

    s, c = "abcdef0123456789", lambda e: s[r(0, e)]
    gen = lambda: c(5) + "".join([c(15) for _ in range(6)])
    x = gen()
    while x in existing:
        x = gen()
    existing.add(x)
    return x.encode("utf-8")


def get_section_title(line):  # type: (bytes) -> bytes | None
    for st in SECTION_TITLES:
        if line.startswith(b"\\" + st):
            return st


def get_in_between(
    buf, start, end, include=False
):  # type: (bytes, bytes, bytes, bool) -> tuple[bytes, bytes] | None
    stk, s = 0, None
    for i in range(len(buf)):
        c = buf[i : i + 1]
        if c == start:
            stk, s = stk + 1, s if s is not None else i
        elif c == end:
            stk -= 1
            if stk == 0:
                end = buf[i + 1 :]
                hit = buf[s : i + 1] if include else buf[s + 1 : i]
                return (hit, end)
    return None


# Checks if the entire section title
# ```
# \Theorem{3.1.4}{Cauchy integral theorem}\label{ab0cc7c}
# ```
# is in one line by making sure all open '{' are closed.
def section_is_one_line(line):  # type: (bytes) -> bool
    stk, t = 0, {b"{": 1, b"}": -1}
    for i in range(len(line)):
        stk += t.get(line[i : i + 1], 0)
    return stk == 0


class Args:
    Action = Literal[
        "build",
        "dev",
        "sha",
        "test",
        "label",
        "generate-section-titles",
    ]
    action = None  # type: Args.Action
    header = None  # type: str
    jobname = None  # type: str
    build_dir = None  # type: str
    show_proofs = None  # type: bool
    show_computes = None  # type: bool
    verbose = None  # type: bool
    tex_files = None  # type: list[str]
    toc = None  # type: bool

    @staticmethod
    def parse():  # type: () -> Args
        p = ArgumentParser(
            prog="pytex",
            description="Custom pdflatex build script with Python3",
        )
        p.add_argument("action", choices=typing.get_args(Args.Action))
        p.add_argument("-H", dest="header", default="headers")
        p.add_argument("-J", "--jobname", default="out")
        p.add_argument("--build-dir", default=".build")
        p.add_argument("--toc", action="store_true")
        p.add_argument("--no-proof", dest="show_proofs", action="store_false")
        p.add_argument("--no-compute", dest="show_computes", action="store_false")
        p.add_argument("--verbose", action="store_true")
        p.add_argument("tex_files", nargs="*")
        args = p.parse_args()
        seen = set()
        tex_files = []
        for f in args.tex_files:
            if f not in seen:
                seen.add(f)
                tex_files.append(f)
        args.tex_files = tex_files
        return args


# get index `i` form list `l`, `d` if out of range
def get(l, i, d=None):  # type: (list[T], int, T | None) -> T
    return l[i] if (i >= 0 and len(l) > i) or (i < 0 and len(l) >= -i) else d


# quick routine to read a file into bytes
def read_file(path):  # type: (str) -> list[bytes]
    with open(path, "rb") as f:
        return f.read()


# lines should not end with newline characters
def write_file(path, lines):  # type: (str, list[bytes]) -> None
    with open(path, "wb") as f:
        f.write(b"\n".join(lines))


def debug():
    pass


# remove all bytes including and within a start and end marker
def remove_in_between(data: bytes, start: bytes, end: bytes):
    buffer, r, n = [], data.find(start), len(end)
    while r >= 0:
        buffer.extend(data[:r])
        data = data[data.find(end) + n :]
        r = data.find(start)
    buffer.extend(data)
    return bytes(buffer)


class PdfLatex:
    # start a subprocess of `pdflatex` ready to take a latex file in
    # from stdin
    def __init__(self, args):  # type: (Args) -> None
        # tells latex compiler to search for .sty packages in this folder.
        os.environ["TEXINPUTS"] = path.join(os.curdir, "tex_modules") + ":"

        j, d = args.jobname, args.build_dir
        cmd = ("pdflatex", "-halt-on-error", f"-output-directory={d}", f"-jobname={j}")
        self.dev_mode = args.action == "dev"
        self.x = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE, env=os.environ)
        self.a = args

    # write tex contents to a file instead of stdin
    def send_to_file(self):
        self.x.kill()
        self.x.stdin = open("build.tex", "wb")

    def write(self, e: bytes):
        self.x.stdin.write(e)
        self.x.stdin.write(b"\n")

    def __compile__(self, filepath: str) -> bytes:
        b = read_file(filepath)
        if not self.a.show_computes:
            b = remove_in_between(b, b"\\begin{compute}", b"\\end{compute}")
        if not self.a.show_proofs:
            b = remove_in_between(b, b"\\begin{proof}", b"\\end{proof}")
        return b

    def generate_toc(self):
        if self.dev_mode or not self.a.toc:
            return
        self.write(b"\\section{Table of Contents}")
        # self.write(b"\\begin{itemize}[itemsep=1em] \\large")
        # self.write(b"\\let\\x\\item\\def\\item#1#2{\\x[]\\href{#1}{#2}}")
        pipe = map(read_file, self.a.tex_files)
        pipe = map(lambda v: v.splitlines(), pipe)

        gib = lambda b, i: get_in_between(b, b"{", b"}", include=i)
        w = lambda v: b"{" + v + b"}"

        for file in pipe:
            section_started = False
            for line in file:
                if not section_started and line.startswith(b"\\section"):
                    section, line = gib(line, True)
                    href, _ = gib(line, True)
                    # self.write(b"\\href" + href + section)
                    self.write(b"{\large "+ section + b"}")
                    self.write(b"\\begin{itemize}[itemsep=0pt]\\footnotesize")
                    continue

                st = get_section_title(line)
                if st is not None:
                    num, line = gib(line, False)
                    name, line = gib(line, True)
                    href, line = gib(line, True)
                    st = w(st + b" " + num)
                    self.write(b"\\item[-]\\href" + href + w(st + b" " + name))

            self.write(b"\\end{itemize}\\vspace{1em}")

    def process_files(self):
        blist = map(self.__compile__, self.a.tex_files)
        for b in blist:
            self.write(b)
            self.write(b"\\newpage")

    def run(self):
        w = self.write
        w(b"\\documentclass{article}")
        w(b"\\usepackage{" + self.a.header.encode("utf8") + b"}")
        w(b"\\begin{document}")
        self.generate_toc()
        self.process_files()
        w(b"\\end{document}")

        self.x.stdin.flush()
        self.x.stdin.close()
        if self.a.verbose:
            self.direct_stdout()
        else:
            self.filtered_stdout()
        self.x.wait()

    def buf_to_stdout(self, buf):  # type: (list[bytes]) -> None
        for l in buf:
            print(l.decode("utf8"), end="")

    def direct_stdout(self):
        self.buf_to_stdout(iter(self.x.stdout.readline, b""))

    def should_print(self, buf):  # type: (list[bytes]) -> bool
        if len(buf) == 0:
            return False
        fl = buf[0]
        if len(buf) < 2 and (b"*\n" == fl or Regex.STAR_NUM.match(fl)):
            return False

        # all substrings are included in any line in the buffer
        inc = lambda x: any(map(lambda l: all(map(lambda x: x in l, x)), buf))
        # buffer has any line that starts with substring
        sw = lambda x: any(map(lambda l: l.startswith(x), buf))

        return not (
            sw(b"This is pdfTeX")
            or sw(b"*geometry*")
            or sw(b"**entering extended mode")
            or sw(b"Package hyperref Warning")
            or sw(b"Underfull \hbox (badness 10000)")
            or inc((b"texlive", b"texmf", b"latex"))  # system package
            or inc((b"texlive", b"texmf", b"pdftex"))  # system package
            or inc((b"(Please type a command or say `\end')\n"))
            or sw(b"LaTeX Warning: You have requested package")
        )

    def err_buf(self, buf):  # type: (list[bytes]) -> None
        s = b"".join(buf).strip().decode("utf8")
        raise Exception("PYTEX ERROR\n" + s)

    # helps to monitor stdout in a less cluttered way
    def filtered_stdout(self):
        buf, is_err = [], False
        lines = iter(self.x.stdout.readline, b"")
        lines = filter(lambda v: v.removesuffix(b"\n"), lines)

        sw = lambda l, x: l.startswith(x)
        for l in lines:
            excl, ast = sw(l, b"!"), sw(l, b"*")
            if excl or ast:
                if is_err and not self.dev_mode:
                    self.err_buf(buf)
                if self.should_print(buf):
                    self.buf_to_stdout(buf)
                buf.clear()
            is_err |= excl
            buf.append(l)

        if is_err and not self.dev_mode:
            self.err_buf(buf)


# [SUBCOMMAND] builds using all the tex_files supplied, in that order
def __build__(args):
    if not path.isdir(args.build_dir):
        os.mkdir(args.build_dir)

    PdfLatex(args).run()

    pdf_basename = f"{args.jobname}.pdf"
    pdf_output = path.join(args.build_dir, pdf_basename)
    if path.isfile(pdf_output):
        os.rename(pdf_output, pdf_basename)


# [SUBCOMMAND] prints a 7-char SHA hash that the user can copy to
# clipboard. This SHA is unique in all ".tex" files that are in the
# current directory and all the current subdirectories.
#
# opinionated quirk: all generated SHAs will start with a letter.
def __sha__(_):
    shas = set()
    for f in map(File, get_tex_files()):
        f.get_labels(shas)
    print(new_sha(shas).decode("utf8"), end="")


# get all instances of `\label{...}` in a file buffer
def get_labels(data):  # type: (bytes) -> list[bytes]
    res, ids = Regex.LABEL.search(data), []
    while res != None:
        ids.append(res.groups()[0])
        data = data[res.span()[1] :]  # seek forward
        res = Regex.LABEL.search(data)
    return ids


# Get all files ending with '.tex' in the user's current directory
def get_tex_files():  # type: () -> list[str]
    files, cwd = [], os.curdir
    for root, _, f in os.walk(cwd):
        f = filter(lambda f: f.endswith(".tex"), f)
        f = map(lambda f: path.join(root, f), f)
        f = map(lambda f: path.relpath(f, cwd), f)
        files.extend(f)
    return files


def get_unique_ids(files):
    # key: id, value: list of files that id was defined in
    ids = {}  # type: dict[bytes, list[bytes]]
    for f in files:
        for label in get_labels(read_file(f)):
            t = ids.get(label, [])
            t.append(f)
            ids[label] = t
    dups = [(k, v) for k, v in ids.items() if len(v) > 1]
    return (dups, list(ids.keys()))


# [TEST]
# Assert that all id definitions of the form `\label{cbae218}` are
# unique in the files supplied
def assert_unique_ids():  # type: () -> bool
    dups, _ = get_unique_ids(get_tex_files())

    if len(dups) > 0:
        print("Duplicate ids found:")
        for k, v in dups:
            print(k.decode("utf8"))
            [print("\t*", v.decode("utf8")) for v in v]

    return len(dups) == 0


# [SUBCOMMAND] checks if everything is in a healthy state
# 1. checks that no two labels have the same SHA
def __test__(_):
    ALL_OK = True
    ALL_OK &= assert_unique_ids()

    if ALL_OK:
        print("All checks passed!")


# [SUBCOMMAND] runs a server that rebuilds the pdf if any file
# changed.
def __dev__(args):
    from watchdog.observers import Observer
    from watchdog.events import FileSystemEventHandler

    now = lambda: datetime.datetime.now().strftime("%H:%M:%S")
    build = lambda: __build__(args)
    report = lambda: print("\x1b[33m[Last build: %s]\x1b[0m" % now())
    build()
    report()

    class EventHandler(FileSystemEventHandler):
        def __init__(self, args):
            self.args = args
            self.last_trigger_time = time.time()

        def on_modified(self, event):
            if not event.src_path.endswith(".tex"):
                return
            current_time = time.time()
            if (current_time - self.last_trigger_time) < 1:
                return
            self.last_trigger_time = current_time
            build()
            report()

    observer = Observer()
    observer.schedule(EventHandler(args), os.curdir, recursive=False)
    observer.start()
    try:
        while True:
            time.sleep(1)
    finally:
        observer.stop()
        observer.join()


def __label__(_):
    shas = set()  # type: set[bytes]
    for f in map(File, get_tex_files()):
        f.get_labels(shas)
        f.check_references(shas)
        f.add_labels(shas)
        f.write()


def __generate_section_titles__(_):
    def gen(t):  # type: (str) -> str
        c, b = lambda v: rf"\ifx&#2&\else{v}\fi", lambda v: "{" + v + "}"
        desc = c("(") + "#2" + c(")")
        return f"\def\{t}#1#2" + b(
            "\subsubsection" + b(t + " {#1}\hspace{0.7em}" + b(desc))
        )

    st = map(lambda v: v.decode("utf8"), SECTION_TITLES)
    for l in map(gen, st):
        print(l)


def main():
    args = Args.parse()
    tbl = {
        "build": __build__,
        "sha": __sha__,
        "dev": __dev__,
        "test": __test__,
        "label": __label__,
        "generate-section-titles": __generate_section_titles__,
    }  # type: dict[Args.Action, Callable]
    tbl[args.action](args)


if __name__ == "__main__":
    main()
