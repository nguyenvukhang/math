#!/usr/bin/env python3

from __utils__ import *
from __args__ import *
from __classes__ import *
from __consts__ import *
from __texfile__ import *
import os, time, datetime
from os import path
from typing import Callable

SHOW_PROOF = False
SHOW_COMPUTE = False


# Get all files ending with '.tex' in the user's current directory
def get_tex_files(recursive=True):  # type: (bool) -> list[str]
    is_tex = lambda f: f.endswith(".tex")
    if recursive:
        files, cwd = [], os.curdir
        for root, _, f in os.walk(cwd):
            f = filter(is_tex, f)
            f = map(lambda f: path.join(root, f), f)
            f = map(lambda f: path.relpath(f, cwd), f)
            files.extend(f)
        return files
    else:
        return [x for x in os.listdir() if is_tex(x)]


# [SUBCOMMAND] builds using all the tex_files supplied, in that order
def __build__(args):  # type: (Args) -> None
    Project(args.tex_files).build(args)


# [SUBCOMMAND] runs a server that rebuilds the pdf if any file
# changed.
def __dev__(args):  # type: (Args) -> None
    project = Project(args.tex_files)

    from watchdog.events import FileSystemEventHandler

    now = lambda: datetime.datetime.now().strftime("%H:%M:%S")
    build = lambda: project.build(args)
    report = lambda: print("\x1b[33m[Last build: %s]\x1b[0m" % now())
    (build(), report())

    class EventHandler(FileSystemEventHandler):
        def __init__(self, args):
            self.args = args
            self.last_trigger_time = time.time()

        def __build__(self):
            current_time = time.time()
            if (current_time - self.last_trigger_time) < 1:
                return
            self.last_trigger_time = current_time
            (build(), report())

        def on_modified(self, event):
            for tf in project.tex_files:
                if event.src_path.endswith(tf.path):
                    tf.reload_index()
                    self.__build__()
                    break

    run_observer(EventHandler(args))


# [SUBCOMMAND] prints a 7-char SHA hash that the user can copy to
# clipboard. This SHA is unique in all ".tex" files that are in the
# current directory and all the current subdirectories.
#
# opinionated quirk: all generated SHAs will start with a letter.
def __sha__(_):
    files = list(map(File, get_tex_files()))
    for file in files:
        file.index()
    all_labels = File.merge_labels(files)
    print(new_sha(all_labels).decode("utf8"), end="")


# [SUBCOMMAND] adds a label and a unique SHA to all marks that don't
# already have a SHA.
def __label__(_):
    files = list(map(File, get_tex_files()))
    for file in files:
        file.index()
    all_labels = File.merge_labels(files)
    for file in files:
        file.add_labels_and_write(all_labels)


def __generate_section_titles__(_):
    def gen(t):  # type: (str) -> str
        c, b = lambda v: rf"\ifx&#2&\else{v}\fi", lambda v: "{" + v + "}"
        desc = c("(") + "#2" + c(")")
        return f"\def{t}#1#2" + b(
            "\subsubsection" + b(t + " {#1}\hspace{0.7em}" + b(desc))
        )

    for l in map(lambda v: gen(v.decode("utf8")), MARKS_WITH_BSLS):
        print(l)


# [SUBCOMMAND] checks if everything is in a healthy state
# 1. checks that no two labels have the same SHA
def __test__(_):
    files = list(map(File, get_tex_files()))
    for file in files:
        file.index()
    File.merge_labels(files)  # should error out if duplicates are found


if __name__ == "__main__":  # int main() {
    args = Args.parse()
    tbl = {
        "build": __build__,
        "dev": __dev__,
        "sha": __sha__,
        "label": __label__,
        "generate-section-titles": __generate_section_titles__,
        "test": __test__,
    }  # type: dict[Args.Action, Callable]
    tbl[args.action](args)
